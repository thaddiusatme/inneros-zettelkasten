"""CLI for reviewing and approving cleanup decisions.

Displays pending moves with metadata, collects user confirmation,
and persists approved decisions to timestamped YAML.
"""

from __future__ import annotations

from pathlib import Path
from typing import Any
from datetime import datetime
import yaml


def review_decisions(*, decision_log_path: Path | str) -> None:
    """Review pending decisions and collect user confirmation.

    Parameters
    ----------
    decision_log_path:
        Path to decision log YAML generated by cleanup_decision_log.generate_decision_log().
    """

    decision_log_path = _coerce_path(decision_log_path)

    # Parse decision log
    decision_data = yaml.safe_load(decision_log_path.read_text())
    items = decision_data.get("items", [])

    # Display and collect confirmations
    for item in items:
        if item.get("status") != "pending":
            continue

        _display_decision(item)
        user_choice = _collect_user_confirmation()
        item["status"] = user_choice

    # Persist approved decisions
    approved_items = [item for item in items if item.get("status") == "approved"]
    if approved_items:
        _persist_approved_decisions(decision_log_path, approved_items)

    # Update decision log with all statuses
    decision_data["items"] = items
    decision_log_path.write_text(yaml.dump(decision_data, default_flow_style=False))


class DecisionDisplayFormatter:
    """Format decision entries for CLI display with metadata."""

    @staticmethod
    def format_move(item: dict[str, Any]) -> str:
        """Format move with source, destination, rationale, and metadata."""

        source = item.get("source", "")
        destination = item.get("destination", "")
        rationale = item.get("rationale", "")

        lines = [f"\n{source} â†’ {destination}", f"  Rationale: {rationale}"]

        # Add metadata if present
        if "trigger" in item:
            lines.append(f"  Trigger: {item['trigger']}")
        if "monitoring" in item:
            lines.append(f"  Monitoring: {item['monitoring']}")

        return "\n".join(lines)


class UserConfirmationCollector:
    """Collect and validate user confirmation for decisions."""

    VALID_CHOICES = {"approve", "skip", "reject"}
    CHOICE_TO_STATUS = {
        "approve": "approved",
        "skip": "skipped",
        "reject": "rejected",
    }

    @staticmethod
    def collect() -> str:
        """Collect user choice and return normalized status."""

        while True:
            choice = input("Approve? (approve/skip/reject): ").strip().lower()
            if choice in UserConfirmationCollector.VALID_CHOICES:
                return UserConfirmationCollector.CHOICE_TO_STATUS[choice]
            print(f"Invalid choice. Please enter one of: {', '.join(UserConfirmationCollector.VALID_CHOICES)}")


class ApprovedDecisionsPersister:
    """Persist approved decisions to timestamped YAML."""

    @staticmethod
    def persist(decision_log_path: Path, approved_items: list[dict[str, Any]]) -> Path:
        """Save approved decisions and return path to persisted file."""

        review_queue = decision_log_path.parent / ".automation" / "review_queue"
        review_queue.mkdir(parents=True, exist_ok=True)

        timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
        approved_log = review_queue / f"cleanup-decisions-{timestamp}.yaml"

        approved_data = {"items": approved_items}
        approved_log.write_text(yaml.dump(approved_data, default_flow_style=False))

        return approved_log


def _display_decision(item: dict[str, Any]) -> None:
    """Display decision with formatted output."""

    formatted = DecisionDisplayFormatter.format_move(item)
    print(formatted)


def _collect_user_confirmation() -> str:
    """Collect user confirmation and return normalized status."""

    return UserConfirmationCollector.collect()


def _persist_approved_decisions(
    decision_log_path: Path,
    approved_items: list[dict[str, Any]],
) -> None:
    """Persist approved decisions to timestamped YAML."""

    ApprovedDecisionsPersister.persist(decision_log_path, approved_items)


def _coerce_path(path: Path | str) -> Path:
    return path if isinstance(path, Path) else Path(path)
