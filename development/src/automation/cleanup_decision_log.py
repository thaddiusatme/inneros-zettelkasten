"""Decision log generator for cleanup inventory.

Transforms inventory records into executable move decisions with metadata,
validation, and user confirmation hooks for DirectoryOrganizer integration.
"""

from __future__ import annotations

from pathlib import Path
from typing import Any, Callable, Mapping
import yaml


def generate_decision_log(
    *,
    inventory_path: Path | str,
    decision_log_path: Path | str,
    on_confirmation: Callable[[Mapping], bool] | None = None,
) -> None:
    """Generate decision log from inventory YAML.

    Parameters
    ----------
    inventory_path:
        Path to inventory YAML generated by cleanup_inventory.generate_inventory().
    decision_log_path:
        Destination for the generated decision log YAML.
    on_confirmation:
        Optional callback for user confirmation. Receives decision entry dict,
        returns True to approve, False to skip.
    """

    inventory_path = _coerce_path(inventory_path)
    decision_log_path = _coerce_path(decision_log_path)
    decision_log_path.parent.mkdir(parents=True, exist_ok=True)

    # Parse inventory YAML
    inventory_data = yaml.safe_load(inventory_path.read_text())
    inventory_items = inventory_data.get("items", [])

    # Transform records to decision entries
    decision_items: list[dict[str, Any]] = []
    for record in inventory_items:
        if record.get("source") == "none":
            continue

        decision_entry = _build_decision_entry(record)

        # Validate entry
        validation_errors = _validate_decision_entry(decision_entry)
        if validation_errors:
            decision_entry["status"] = "invalid"
            decision_entry["validation_errors"] = validation_errors
        elif on_confirmation and not on_confirmation(decision_entry):
            decision_entry["status"] = "skipped"

        decision_items.append(decision_entry)

    # Detect conflicts
    conflicts = _detect_conflicts(decision_items)
    if conflicts:
        for conflict in conflicts:
            conflict["status"] = "conflict"

    # Write decision log
    decision_log_data = {"items": decision_items}
    decision_log_path.write_text(yaml.dump(decision_log_data, default_flow_style=False))


def _build_decision_entry(record: Mapping) -> dict[str, Any]:
    """Transform inventory record into decision entry with status."""

    entry: dict[str, Any] = {
        "source": record.get("source"),
        "destination": record.get("destination"),
        "rationale": record.get("rationale"),
        "status": "pending",
    }

    # Preserve metadata fields if present
    if "trigger" in record:
        entry["trigger"] = record["trigger"]
    if "monitoring" in record:
        entry["monitoring"] = record["monitoring"]

    return entry


def _validate_decision_entry(entry: dict[str, Any]) -> list[str]:
    """Validate decision entry schema and content.

    Returns list of validation errors (empty if valid).
    """

    errors: list[str] = []

    # Check required fields
    if not entry.get("source"):
        errors.append("Missing required field: source")
    if not entry.get("destination"):
        errors.append("Missing required field: destination")
    if not entry.get("status"):
        errors.append("Missing required field: status")

    # Validate paths are relative
    source = entry.get("source", "")
    destination = entry.get("destination", "")
    if source.startswith("/"):
        errors.append("Source path must be relative to vault root")
    if destination.startswith("/"):
        errors.append("Destination path must be relative to vault root")

    return errors


def _detect_conflicts(items: list[dict[str, Any]]) -> list[dict[str, Any]]:
    """Detect circular moves and duplicate destinations.

    Returns list of conflicting entries.
    """

    conflicts: list[dict[str, Any]] = []
    destinations: dict[str, str] = {}

    for item in items:
        if item.get("status") in ("invalid", "skipped"):
            continue

        dest = item.get("destination", "")
        source = item.get("source", "")

        # Check for duplicate destination
        if dest in destinations:
            conflicts.append(item)
            continue

        # Check for circular move (source == another's destination)
        if source in destinations.values():
            conflicts.append(item)
            continue

        destinations[dest] = source

    return conflicts


def _coerce_path(path: Path | str) -> Path:
    return path if isinstance(path, Path) else Path(path)
